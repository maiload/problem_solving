# BFS / DFS â­â­â­â­â­

[â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°](../../README.md)

---

## ğŸ“ ê´€ë ¨ ë¬¸ì„œ
- [ê·¸ë˜í”„](../graph/README.md)
- [íŠ¸ë¦¬](../tree/README.md)
- [ì¬ê·€í•¨ìˆ˜ / ë°±íŠ¸ë˜í‚¹](../recursion/README.md)

---

## ğŸ”‘ í‚¤ì›Œë“œ

**ê³µí†µ**: ì—°ê²°, ì´ë™, ì˜ì—­, ë°©ë¬¸, ìƒí•˜ì¢Œìš°, ì¸ì ‘í•œ ì¹¸, ê²©ì

| DFS | BFS |
|-----|-----|
| ëê¹Œì§€ í™•ì¸, ì „ë¶€ ì¡°ì‚¬ | í™•ì‚°, í¼ì§, ë™ì‹œì—, ìµœì†Œ, ê°€ì¥ ë¹ ë¥´ê²Œ |

## ğŸ§© ìì£¼ ì„ì´ëŠ” ì¡°í•©
- BFS + ì´ë¶„ íƒìƒ‰(check)
- BFS + ì‹œë®¬ë ˆì´ì…˜
- DFS + ë°±íŠ¸ë˜í‚¹(ë‹¨ìˆœ)

## âŒ ì‹¤ìˆ˜ í¬ì¸íŠ¸
- visited ì²´í¬ ì‹œì  (BFS: íì— ë„£ì„ ë•Œ, DFS: ë°©ë¬¸í•  ë•Œ)
- ê²©ì ë¬¸ì œì—ì„œ ë²”ìœ„ ì²´í¬ ëˆ„ë½
- ë°©í–¥ ë°°ì—´ ì¸ë±ìŠ¤ ì‹¤ìˆ˜

## âš ï¸ ì£¼ì˜í•  ì 
- dfs/bfsì˜ ì¸ìëŠ” **ë‹¤ìŒìœ¼ë¡œ íƒìƒ‰í•  ì •ì (ìƒíƒœ)**
- visitedëŠ” **ê·¸ ì •ì (ìƒíƒœ)ì„ ì‹ë³„í•˜ëŠ” ìµœì†Œ ì •ë³´**ë¡œ êµ¬ì„±
- ëŒ€ë¶€ë¶„ **ì¸ì ‘ ë¦¬ìŠ¤íŠ¸** ë°©ì‹ ì‚¬ìš© â†’ O(V + E)

---

## ğŸ“Š ì‹œê°„ ë³µì¡ë„
- ì¸ì ‘ ë¦¬ìŠ¤íŠ¸: `O(V + E)`
- ì¸ì ‘ í–‰ë ¬: `O(VÂ²)`

> ê²©ì(4ë°©í–¥)ì˜ ê²½ìš°: O(V + 4V) = O(V)

---

## DFS (Depth-First Search)

í•œ ë°©í–¥ìœ¼ë¡œ ëê¹Œì§€ íƒìƒ‰í•œ ë’¤, ë§‰íˆë©´ ë˜ëŒì•„ê°€ì„œ ë‹¤ë¥¸ ê¸¸ì„ íƒìƒ‰

**êµ¬í˜„**: ì¬ê·€ í˜¸ì¶œ / Stack

**íŠ¹ì§•**:
- ê²½ë¡œ íƒìƒ‰, ë°±íŠ¸ë˜í‚¹, ì¡°í•©/ìˆœì—´ ë“±ì— ì‚¬ìš©
- ë” ì´ìƒ ë°©ë¬¸í•  ì •ì ì´ ì—†ìœ¼ë©´ íƒˆì¶œ (ëª…ì‹œì  if íƒˆì¶œë¬¸ ì—†ìŒ)

---

## BFS (Breadth-First Search)

ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ íƒìƒ‰

**êµ¬í˜„**: Queue

**íŠ¹ì§•**:
- **ìµœë‹¨ ê±°ë¦¬** (ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„) íƒìƒ‰ì— ì‚¬ìš©
- visited ì²´í¬ëŠ” **íì— ë„£ëŠ” ì‹œì **ì— ìˆ˜í–‰ (ì¤‘ë³µ ë°©ì§€)
- visited ë°°ì—´ì„ ê±°ë¦¬ ë°°ì—´ë¡œ ì‚¬ìš© â†’ ë°©ë¬¸ ì—¬ë¶€ + íƒìƒ‰ ë ˆë²¨ ë™ì‹œ ê´€ë¦¬
  - ì´ˆê¸°ê°’ -1ë¡œ ì„¤ì •: `Arrays.fill(visited, -1);`

---

## ğŸ§± ê¸°ë³¸ ì½”ë“œ

**DFS (recursion)**
```java
static void dfs(int node) {
    visited[node] = true;
    
    for (int next : graph[node]) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}
```

**BFS (queue)**
```java
static void bfs(int start) {
    ArrayDeque<Integer> q = new ArrayDeque<>();
    q.offer(start);
    visited[start] = 0;

    while (!q.isEmpty()) {
        int now = q.poll();
        for (int next : graph[now]) {
            if (visited[next] == -1) {
                q.offer(next);
                visited[next] = visited[now] + 1;
            }
        }
    }
}
```

**2ì°¨ì› ê²©ì íƒìƒ‰**
```java
int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

for (int[] d : dir) {
    int nR = cR + d[0];
    int nC = cC + d[1];
    if (nR >= 0 && nR < N && nC >= 0 && nC < M) {
        // ìœ íš¨í•œ ì¢Œí‘œ
    }
}
```

> **Tip.** ì¢Œí‘œë¥¼ íì— ë„£ì„ ë•Œ ë³„ë„ í´ë˜ìŠ¤ ì—†ì´ ê°€ëŠ¥
> ```java
> // ë°©ë²• 1: ì—°ì† offer/poll
> ArrayDeque<Integer> q = new ArrayDeque<>();
> q.offer(x); q.offer(y);
> int x = q.poll(), y = q.poll();
>
> // ë°©ë²• 2: ë°°ì—´ë¡œ ë¬¶ì–´ì„œ
> ArrayDeque<int[]> q = new ArrayDeque<>();
> q.offer(new int[]{x, y});
> int[] cur = q.poll();
> int x = cur[0], y = cur[1];
> ```

---

## ê·¸ë˜í”„ í‘œí˜„ ë°©ë²•

| ë°©ì‹ | ê³µê°„ | ì „ì²´ íƒìƒ‰ | ì—°ê²° í™•ì¸ |
|-----|-----|---------|---------|
| ì¸ì ‘ í–‰ë ¬ | O(VÂ²) | O(VÂ²) | O(1) |
| ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ | O(V+E) | O(V+E) | O(deg) |

> ì¼ë°˜ì ìœ¼ë¡œ **ì¸ì ‘ ë¦¬ìŠ¤íŠ¸**ê°€ ìœ ë¦¬ (ê°„ì„ ì´ ë°€ì§‘í•˜ì§€ ì•Šì€ ê²½ìš°)

**ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬í˜„**
```java
ArrayList<Integer>[] graph = new ArrayList[V + 1];
for (int i = 0; i <= V; i++) {
    graph[i] = new ArrayList<>();
}
graph[src].add(dst);
```
