# Brute Force (완전 탐색)

[← 메인으로 돌아가기](../../README.md)

---

## 📎 관련 문서
- [재귀 / 백트래킹](./recursion.md)
- [순열 / 조합](./permutation-combination.md)
- [BFS / DFS](../bfs-dfs/README.md)

---

## 🔑 키워드
`완전 탐색` `모든 경우` `구현` `시뮬레이션` `규칙대로`

## ❌ 실수 포인트
- 시간 복잡도 계산 실수 (N! vs 2^N vs N^2)
- 경계 조건 누락
- 시뮬레이션 순서 실수

## ⚠️ 주의할 점
- 완전 탐색 가능 여부 먼저 판단 (N ≤ 10이면 N!, N ≤ 20이면 2^N)
- 최적화 전에 정확한 완전 탐색 먼저 구현

---

## 📊 시간 복잡도 기준

| N 범위 | 가능한 복잡도 |
|-------|-------------|
| N ≤ 10 | O(N!) |
| N ≤ 20 | O(2^N) |
| N ≤ 100 | O(N^3) |
| N ≤ 1,000 | O(N^2) |
| N ≤ 100,000 | O(NlogN) |
| N ≤ 10,000,000 | O(N) |

---

## 완전 탐색 구현 방법

| 방법 | 설명 | 복잡도 |
|-----|------|-------|
| 반복문 | 중첩 for문 | O(N^k) |
| 재귀 | 순열/조합/백트래킹 | O(N!) or O(2^N) |
| 비트마스크 | 부분집합 | O(2^N) |

---

## 비트마스크

```java
// 부분집합 순회
for (int mask = 0; mask < (1 << N); mask++) {
    for (int i = 0; i < N; i++) {
        if ((mask & (1 << i)) != 0) {
            // i번째 원소 선택됨
        }
    }
}
```

| 연산 | 코드 | 설명 |
|-----|------|-----|
| i번째 비트 확인 | `(mask & (1 << i)) != 0` | i번째 선택 여부 |
| i번째 비트 켜기 | `mask \| (1 << i)` | i번째 선택 |
| i번째 비트 끄기 | `mask & ~(1 << i)` | i번째 해제 |
| i번째 비트 토글 | `mask ^ (1 << i)` | i번째 반전 |

---

## Simulation (시뮬레이션)

문제에서 주어진 규칙대로 그대로 구현

### 자주 나오는 패턴

**방향 이동 (4방향)**
```java
int[] dr = {-1, 1, 0, 0};
int[] dc = {0, 0, -1, 1};

for (int d = 0; d < 4; d++) {
    int nr = r + dr[d];
    int nc = c + dc[d];
    if (nr >= 0 && nr < N && nc >= 0 && nc < M) {
        // 이동 가능
    }
}
```

**방향 회전**
```java
int[] dr = {-1, 0, 1, 0};  // 상, 우, 하, 좌
int[] dc = {0, 1, 0, -1};

int dir = 0;
dir = (dir + 1) % 4;  // 오른쪽 90도 회전
dir = (dir + 3) % 4;  // 왼쪽 90도 회전
```

**격자 범위 체크**
```java
boolean inRange(int r, int c) {
    return r >= 0 && r < N && c >= 0 && c < M;
}
```
