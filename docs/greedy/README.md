# 그리디 (Greedy) ⭐⭐⭐⭐

[← 메인으로 돌아가기](../../README.md)

---

## 🔑 키워드
`최소 개수` `최대 개수` `가장 먼저` `가장 큰/작은` `정렬 후 선택`

## 🧩 자주 섞이는 조합
- 그리디 + 정렬
- 그리디 + 우선순위 큐
- 그리디 + 이분 탐색

## ❌ 실수 포인트
- 그리디 적용 가능 여부 판단 실수
- 정렬 기준 설정 오류
- 반례 케이스 놓침

## ⚠️ 주의할 점
- **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해로 이어져야 함
- **탐욕적 선택 속성**: 현재 최선의 선택이 이후 선택에 영향을 주지 않아야 함
- 확신이 없으면 DP나 완전탐색 고려

---

## 📊 시간 복잡도
- 정렬 기반: `O(NlogN)`
- 단순 순회: `O(N)`

---

## 개념

매 순간 **현재 상황에서 가장 좋아 보이는 선택**을 하는 알고리즘

**그리디가 적용 가능한 조건**:
1. 현재 선택이 이후 선택에 영향을 주지 않음
2. 부분 최적해가 전체 최적해로 이어짐

---

## 대표 유형

### 1. 정렬 후 순차 처리
```java
Arrays.sort(arr);
for (int i = 0; i < N; i++) {
    // 정렬된 순서대로 최적 선택
}
```

### 2. 회의실 배정 (끝나는 시간 기준 정렬)
```java
Arrays.sort(meetings, (a, b) -> a[1] - b[1]);
int end = 0, count = 0;
for (int[] m : meetings) {
    if (m[0] >= end) {
        count++;
        end = m[1];
    }
}
```

### 3. 우선순위 큐 활용
```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
for (int x : arr) {
    pq.offer(x);
    // 조건에 따라 poll
}
```

---

## 그리디 vs DP

| 구분 | 그리디 | DP |
|-----|-------|-----|
| 접근 | 현재 최선 선택 | 모든 경우 고려 |
| 시간 | 빠름 | 상대적으로 느림 |
| 적용 | 조건 만족 시 | 항상 가능 |

> 그리디가 적용 안 되면 DP 고려
