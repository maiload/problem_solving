# 시간 복잡도 (Time Complexity)

[← 메인으로 돌아가기](../../README.md)

---

## 개념
- 입력 크기에 비해 수행 시간이 얼마나 걸리는지
- 주로 `Big-O` 표기법 사용
- 최악의 상황을 포함한 시간의 상한선
- **1초 ≈ 1억(10^8)번 연산** 기준으로 추정

---

## 복잡도 순서

```
1 < logN < √N < N < NlogN < N² < 2ᴺ < N!
```

---

## N 크기별 허용 알고리즘

| N 범위 | 허용 복잡도 | 대표 알고리즘 |
|--------|------------|--------------|
| N ≤ 10 | O(N!) | 순열, 완전탐색 |
| N ≤ 20 | O(2ᴺ) | 부분집합, 백트래킹 |
| N ≤ 100 | O(N³) | 플로이드 워셜 |
| N ≤ 1,000 | O(N²) | 버블/선택 정렬, 2중 반복문 |
| N ≤ 100,000 | O(NlogN) | 퀵/병합 정렬, 이분 탐색 |
| N ≤ 10,000,000 | O(N) | 투포인터, 해시, 카운팅 |
| N > 10,000,000 | O(logN) | 이분 탐색 |

---

## log 계산법

> 이분탐색, 분할정복, 트리 구조 등은 **범위를 절반씩 줄이는 과정**이 반복되기 때문에,
> 알고리즘에서 `logN`은 관습적으로 **log₂N**을 의미

### 예시: log₂(20억)
```
log₂(10) ≈ 3.3

log₂(2 × 10⁹)
= log₂(2) + log₂(10⁹)
= 1 + 9 × log₂(10)
≈ 1 + 9 × 3.3
≈ 30.7
```

> 즉, 20억 개의 데이터도 이분탐색으로 **약 31번** 만에 탐색 가능
