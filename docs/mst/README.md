# MST (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)

[â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°](../../README.md)

---

## ğŸ“ ê´€ë ¨ ë¬¸ì„œ
- [ê·¸ë˜í”„](../graph/README.md)

---

## ğŸ”‘ í‚¤ì›Œë“œ
`ìµœì†Œ ë¹„ìš©` `ëª¨ë“  ì •ì  ì—°ê²°` `N-1ê°œ ê°„ì„ ` `ì‚¬ì´í´ ì—†ìŒ`

## ğŸ§© ìì£¼ ì„ì´ëŠ” ì¡°í•©
- í¬ë£¨ìŠ¤ì¹¼ + Union-Find
- í”„ë¦¼ + ìš°ì„ ìˆœìœ„ í

## âŒ ì‹¤ìˆ˜ í¬ì¸íŠ¸
- ê°„ì„  ì •ë ¬ ë°©í–¥ ì°©ê° (ë¹„ìš© ì˜¤ë¦„ì°¨ìˆœ)
- Union-Findì—ì„œ find í›„ union ì•ˆ í•¨
- ì—°ê²°ëœ ê°„ì„  ìˆ˜ ì²´í¬ ëˆ„ë½ (N-1ê°œ)

## âš ï¸ ì£¼ì˜í•  ì 
- ê°„ì„  ì ìœ¼ë©´ â†’ í¬ë£¨ìŠ¤ì¹¼
- ê°„ì„  ë§ìœ¼ë©´ â†’ í”„ë¦¼

---

## ğŸ“Š ì‹œê°„ ë³µì¡ë„

| ì•Œê³ ë¦¬ì¦˜ | ì‹œê°„ ë³µì¡ë„ | ì í•©í•œ ê²½ìš° |
|---------|-----------|-----------|
| í¬ë£¨ìŠ¤ì¹¼ | O(ElogE) | ê°„ì„  ì ì„ ë•Œ (í¬ì†Œ ê·¸ë˜í”„) |
| í”„ë¦¼ | O(ElogV) | ê°„ì„  ë§ì„ ë•Œ (ë°€ì§‘ ê·¸ë˜í”„) |

---

## í¬ë£¨ìŠ¤ì¹¼ (Kruskal)

ê°„ì„  ì¤‘ì‹¬ - ê°€ì¥ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒ

1. ê°„ì„ ì„ ë¹„ìš© ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
2. ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´ ê°„ì„  ì„ íƒ (Union-Find)
3. N-1ê°œ ê°„ì„  ì„ íƒí•˜ë©´ ì¢…ë£Œ

```java
// ê°„ì„  ì •ë ¬ (ë¹„ìš© ì˜¤ë¦„ì°¨ìˆœ)
int[][] edges;  // {from, to, cost}
Arrays.sort(edges, (a, b) -> a[2] - b[2]);

int[] parent = new int[N];
for (int i = 0; i < N; i++) parent[i] = i;

int count = 0, total = 0;
for (int[] e : edges) {
    if (find(e[0]) != find(e[1])) {   // ê°™ì€ ì§‘í•©ì´ ì•„ë‹ˆë©´ (ì‚¬ì´í´ X)
        union(e[0], e[1]);            // ë‘ ì§‘í•© í•©ì¹˜ê¸°
        total += e[2];
        if (++count == N - 1) break;
    }
}

// find: ë£¨íŠ¸(ëŒ€í‘œ) ì°¾ê¸°
int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]);
}

// union: ë‘ ì§‘í•© í•©ì¹˜ê¸°
void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);
    if (rootA != rootB) {
        parent[rootB] = rootA;
    }
}
```

---

## í”„ë¦¼ (Prim)

ì •ì  ì¤‘ì‹¬ - ì—°ê²°ëœ ì •ì ì—ì„œ ê°€ì¥ ì‘ì€ ê°„ì„  ì„ íƒ

1. ì‹œì‘ ì •ì ì—ì„œ ì¶œë°œ
2. í˜„ì¬ íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ì‘ì€ ê°„ì„ ìœ¼ë¡œ ìƒˆ ì •ì  ì—°ê²°
3. Nê°œ ì •ì  ëª¨ë‘ ì—°ê²°ë˜ë©´ ì¢…ë£Œ

```java
List<int[]>[] graph;  // graph[from] = {to, cost}
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
boolean[] visited = new boolean[N];

pq.offer(new int[]{0, 0});  // {ì •ì , ë¹„ìš©}
int count = 0, total = 0;

while (!pq.isEmpty()) {
    int[] cur = pq.poll();
    int node = cur[0], cost = cur[1];

    if (visited[node]) continue;
    visited[node] = true;
    total += cost;

    if (++count == N) break;

    for (int[] next : graph[node]) {
        if (!visited[next[0]]) {
            pq.offer(next);
        }
    }
}
```

---

## í¬ë£¨ìŠ¤ì¹¼ vs í”„ë¦¼

| êµ¬ë¶„ | í¬ë£¨ìŠ¤ì¹¼ | í”„ë¦¼ |
|-----|---------|-----|
| ë°©ì‹ | ê°„ì„  ì¤‘ì‹¬ | ì •ì  ì¤‘ì‹¬ |
| ìë£Œêµ¬ì¡° | Union-Find | PriorityQueue |
| ê°„ì„  ì ì„ ë•Œ | âœ… ìœ ë¦¬ | |
| ê°„ì„  ë§ì„ ë•Œ | | âœ… ìœ ë¦¬ |
| ì…ë ¥ í˜•íƒœ | ê°„ì„  ë¦¬ìŠ¤íŠ¸ | ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ |

> **ì½”í…Œì—ì„œëŠ” í¬ë£¨ìŠ¤ì¹¼ì´ ë” ìì£¼ ì¶œì œ** (Union-Find í™œìš©)
